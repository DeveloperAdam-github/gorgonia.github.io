<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>VM on Gorgonia</title><link>/reference/vm/</link><description>Recent content in VM on Gorgonia</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 29 Oct 2019 14:59:59 +0100</lastBuildDate><atom:link href="/reference/vm/index.xml" rel="self" type="application/rss+xml"/><item><title>LispMachine</title><link>/reference/vm/lispmachine/</link><pubDate>Tue, 29 Oct 2019 19:50:15 +0100</pubDate><guid>/reference/vm/lispmachine/</guid><description>The LispMachine was designed to take a graph as an input, and executes directly on the nodes of the graph. If the graph change, simply create a new lightweight LispMachine to execute it on. The LispMachine is suitable for tasks such as creating recurrent neural networks without a fixed size.
The trade-off is that executing a graph on LispMachine is generally slower than on TapeMachine, given the same static &amp;ldquo;image&amp;rdquo; of a graph.</description></item><item><title>Tapemachine</title><link>/reference/vm/tapemachine/</link><pubDate>Tue, 29 Oct 2019 19:50:15 +0100</pubDate><guid>/reference/vm/tapemachine/</guid><description>The TapeMachine is useful for executing expressions that are generally static (that is to say the computation graph does not change). Due to its static nature, the TapeMachine is good for running expressions that are compiled-once-run-many-times (such as linear regression, SVM and the like).
Technical details The TapeMachine pre-compiles a graph into a list of instructions, then executes the instructions linearly and sequentially. The main trade-off is dynamism. Graphs cannot be dynamically created on the fly as a re-compilation process is required (and compilation is relatively expensive).</description></item></channel></rss>
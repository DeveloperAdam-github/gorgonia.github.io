<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>main on Gorgonia</title><link>https://gorgonia.org/ja/</link><description>Recent content in main on Gorgonia</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 29 Oct 2019 14:59:59 +0100</lastBuildDate><atom:link href="https://gorgonia.org/ja/index.xml" rel="self" type="application/rss+xml"/><item><title>計算グラフ</title><link>https://gorgonia.org/ja/about/computation-graph/</link><pubDate>Sun, 10 Nov 2019 21:09:19 +0100</pubDate><guid>https://gorgonia.org/ja/about/computation-graph/</guid><description>Gorgonia はグラフベース _Note_：この記事は このブログ投稿 からインスピレーションを得ています。
Tensorflow や Theano など殆どの深層学習ライブラリと同様に、Gorgonia は方程式がグラフで表現できるという概念に依存しています。
方程式グラフをプログラマーが操作できる ExprGraph オブジェクトとして公開します。
ですので以下の様に書く代わりに:
func main() { fmt.Printf(&amp;#34;%v&amp;#34;, 1+1) } プログラマはこう書くのです:
func main() { // Create a graph. g := gorgonia.NewGraph() // Create a node called &amp;#34;x&amp;#34; with the value 1. x := gorgonia.NodeFromAny(g, 1, gorgonia.WithName(&amp;#34;x&amp;#34;)) // Create a node called &amp;#34;y&amp;#34; with the value 1. y := gorgonia.NodeFromAny(g, 1, gorgonia.WithName(&amp;#34;y&amp;#34;)) // z := x + y z := gorgonia.</description></item><item><title>こんにちわ世界</title><link>https://gorgonia.org/ja/tutorials/hello-world/</link><pubDate>Tue, 29 Oct 2019 17:54:31 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/hello-world/</guid><description>これはGorgoniaでとても簡単な計算を行うための段階的なチュートリアルです。
私たちのゴールはGorgoniaのすべての配管を使用して簡単な操作を行うことです:
$ f(x,y) = x + y $
値は x = 2 と y = 5
どの様に動作するか x + y = z の評価はグラフで表す事ができます:
graph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y 結果を計算する為に4つのステップを使います:
Gorgonia で式の様なグラフを作成する nodes x と y に幾つかの値を設定する gorgonia vm上でグラフを起動する node zからvalueを取り出す * グラフの作成 以下の方法で空の式グラフを作成します:
g := gorgonia.NewGraph() ノードの作成 いくつかのノードを作成しそれらを ExprGraph に関連付けます。
var x, y, z *gorgonia.Node プレースホルダの作成 xとyはスカラー変数です。対応するノードは次のように作成できます:
x = gorgonia.</description></item><item><title>簡単なニューラルネットの構築 (MNIST)</title><link>https://gorgonia.org/ja/tutorials/mnist/</link><pubDate>Tue, 29 Oct 2019 20:09:05 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/mnist/</guid><description>はじめに これは MNIST データセットを使って convocation neural network を段階的に構築し練習する為のチュートリアルです。
完全なコードは、Gorgonia メインリポジトリの examples ディレクトリにあります。 このチュートリアルの目的はコードを詳細に説明することです。 仕組みの詳細については、次の書籍で見ることができます。 Go Machine Learning Projects
データセット このパートではデータセットの読み込みと表示について説明します。ニューラルネットの個所に直接ジャンプしたい場合はスキップして Convolution Neural Net part に進んでください。
学習およびテストセットは次からダウンロードできます。 Yann LeCun&amp;rsquo;s MNIST website
train-images-idx3-ubyte.gz: training set images (9912422 bytes) train-labels-idx1-ubyte.gz: training set labels (28881 bytes) t10k-images-idx3-ubyte.gz: test set images (1648877 bytes) t10k-labels-idx1-ubyte.gz: test set labels (4542 bytes) Every image/label starts with a magic number. The encoding/binary package of the standard library of Go makes it easy to read those files.</description></item><item><title>Iris データセットでの多変量線形回帰</title><link>https://gorgonia.org/ja/tutorials/iris/</link><pubDate>Thu, 31 Oct 2019 14:53:37 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/iris/</guid><description>はじめに Gorgoniaを使用して線形回帰モデルを作成します。
ゴールは以下に与えられた特性を考慮して花の種別を予測することです:
sepal_length sepal_width petal_length petal_width 存在する種別は以下の通り:
setosa virginica versicolor このチュートリアルのゴールはgorgoniaを使用して、与えられたirisデータセットから $\Theta$ の正しい値を見つけ以下のようなcliユーティリティを作成することです:
./iris sepal length: 5 sepal width: 3.5 petal length: 1.4 sepal length: 0.2 It is probably a setosa このチュートリアルは学術目的の為の物です。Gorgoniaでこれをどの様にして行うかを説明することがゴールです; これは特定の問題に対する最先端の答えではありません。
数学的表現 良くある花弁の長さと幅だけでなく、がく片の長さと幅の関数であった場合とその種別について考察します。
したがって $y$ が種別の値であると考える場合に解決すべき方程式は次の通りです:
$$ y = \theta_0 + \theta_1 * sepal\_length + \theta_2 * sepal\_width + \theta_3 * petal\_length + \theta_4 * petal\_width$$
ベクトルを考慮した場合の $x$ と $\Theta$ はこうなります:</description></item><item><title>データフレームからテンソルを作成 (gota)</title><link>https://gorgonia.org/ja/how-to/dataframe/</link><pubDate>Wed, 30 Oct 2019 22:57:09 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/dataframe/</guid><description>このハウツーでは、gotaを使用してデータフレームからテンソルを作成する方法を説明します。 The goal is to read a csv file and create a *tensor.Dense with shape (2,2). ゴールは、csvファイルを読み取り、(2,2) のシェイプの* tensor.Denseを作成することです。
csvファイルからデータフレームを作成する 以下のコンテンツのcsvファイルを考えます:
sepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... これはIris flower data setからの抜粋です。 データセットのコピーはここから見つける事ができます。
種別以外のすべての値を含むテンソルを作成します。
gotaを使用してデータフレームを作成する gotaのデータフレームパッケージにはio.Readerを引数として取る関数ReadCSVがあります。
f, err := os.Open(&amp;#34;iris.csv&amp;#34;) if err != nil { log.Fatal(err) } defer f.</description></item><item><title>Weightsの保存</title><link>https://gorgonia.org/ja/how-to/save-weights/</link><pubDate>Tue, 29 Oct 2019 20:07:16 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/save-weights/</guid><description>ゴール このハウツーのゴールはノードの値を保存して復元する方法を説明することです。
実装 現状できる最善の方法は、対応するノードの値を保存して復元することです。
テンソルはGobEncodeおよびGobDecodeインターフェースを実現しており、これが最良のオプションです。 バックエンドを要素のスライスとして保存することもできますがこれは少し複雑です。
これを行うサンプルコードを以下に示します(まったく最適化していません。自由に修正してください):
package main import ( &amp;#34;encoding/gob&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;gorgonia.org/gorgonia&amp;#34; &amp;#34;gorgonia.org/tensor&amp;#34; ) var ( backup = &amp;#34;/tmp/example_gorgonia&amp;#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // Create the graph x = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(&amp;#34;x&amp;#34;)) y = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(&amp;#34;y&amp;#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.</description></item><item><title>Automatic Differentiation</title><link>https://gorgonia.org/ja/about/differentiation/autodiff/</link><pubDate>Tue, 29 Oct 2019 19:49:25 +0100</pubDate><guid>https://gorgonia.org/ja/about/differentiation/autodiff/</guid><description>This page will explain how automatic differentiation works</description></item><item><title>数式微分</title><link>https://gorgonia.org/ja/about/differentiation/symbolicdiff/</link><pubDate>Tue, 29 Oct 2019 19:49:25 +0100</pubDate><guid>https://gorgonia.org/ja/about/differentiation/symbolicdiff/</guid><description>このページは数式微分の仕組みについて説明します</description></item></channel></rss>
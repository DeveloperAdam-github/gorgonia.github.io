[{"uri":"/fr/getting-started/","title":"Premiers pas","tags":[],"description":"Démarrer rapidement avec Gorgonia","content":" Obtenir Gorgonia Gorgonia est go-gettable et supporte les go-modules. Pour récupérer la bibliothèque ainsi que ses dépendances, il suffit d\u0026rsquo;exécuter:\n$ go get gorgonia.org/gorgonia Premier programme pour faire un calcul simple Créer ce programme simple dans un fichier main.go pour vérifier que tout est correctement installé:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) } Exécuter le programme devrait afficher le résultat 4.5.\nPour plus d\u0026rsquo;explications sur le fonctionnement, veuillez consulter le tutoriel Hello World.\n"},{"uri":"/fr/tutorials/","title":"Tutoriels","tags":[],"description":"Tutoriels sur quelques cas d&#39;usage","content":" Tutoriels tutoriels pour démarrer sur quelques cas d\u0026rsquo;usage de Gorgonia.\nCes tutoriels:\n sont orientés apprentissage sont une introduction pour les nouveaux venus. sont une leçon  Analogie: apprendre à un enfant à cuisines\nListe des tutoriels disponibles  Régression linéaire multivariée sur le dataset Iris   "},{"uri":"/fr/tutorials/iris/","title":"Régression linéaire multivariée sur le dataset Iris","tags":[],"description":"","content":" A propos Nous allons utiliser Gorgonia pour créer un modèle de régression linéaire.\nLe but de ce tutoriel est de prédire l\u0026rsquo;espèce d\u0026rsquo;une fleur en fonction de ses caractéristiques:\n sepal_length // longueur du sépale sepal_width // largeur du sépale petal_length // longueur du pétale petal_width // largeurdu pétale  Les espèces que nous voulons prédire sont:\n setosa virginica versicolor  Le but de ce tutoriel est de programmer Gorgonia pour qu\u0026rsquo;il trouve seul les paramètres qui permettent de déterminer la relation entre les attributs et le spécimen. À la fin, nous écrirons un utilitaire CLI (autonome) dont l\u0026rsquo;interface sera la suivante:\n./iris sepal length: 5 sepal width: 3.5 petal length: 1.4 sepal length: 0.2 It is probably a setosa Ce tutoriel est à vocation académique. Son but est de décrire comment réaliser une régression linéaire multivariée avec Gorgonia; Ainsi, le modèle utilisé n\u0026rsquo;est pas la meilleur réponse à ce problème particulier.\n Représentation Mathématique Nous considérons que l\u0026rsquo;espèce d\u0026rsquo;une Iris est fonction de la longueur et de la largeur de son sépale ainsi que de la longueur et de la largeur de son pétale.\nPar conséquent, soit $y$ une valeur représentant l\u0026rsquo;espèce, l\u0026rsquo;équation que nous essayons de résoudre est:\n$$ y = \\theta_0 + \\theta_1 * sepal\\_length + \\theta_2 * sepal\\_width + \\theta_3 * petal\\_length + \\theta_4 * petal\\_width$$\nConsidérons à présent les vecteurs $x$ et $\\Theta$ suivants:\n$$ x = \\begin{bmatrix} sepal\\_length \u0026amp; sepal\\_width \u0026amp; petal\\_length \u0026amp; petal\\_width \u0026amp; 1\\end{bmatrix}$$\n$$ \\Theta = \\begin{bmatrix} \\theta_4 \\theta_3 \\theta_2 \\theta_1 \\theta_0 \\end{bmatrix} $$\nNous pouvons réécrire l\u0026rsquo;équation:\n$$y = x\\cdot\\Theta$$\nRégression linéaire Pour trouver les bonnes valeurs de $\\Theta$ rendant l\u0026rsquo;équation vraie pour la majorité des Iris, nous allons utiliser une régression linéaire.\nNous allons encoder les données d\u0026rsquo;entrainement (les constats fait sur plusieurs fleurs) dans une matrice $X$. $X$ est composée de 5 colonnes: sepal length, sepal width, petal length, petal width et une colonne contenant 1 pour le biais. Chaque ligne de la matrice représente une fleur.\nNous allons encoder les espèces dans un vecteur colonne $Y$ composé de nombres flottants.\n setosa = 1.0 virginica = 2.0 versicolor = 3.0  Lors de la phase d\u0026rsquo;apprentissage, le coût est exprimé de la manière suivante:\n$cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$\nNous allons utiliser la méthode de descente de gradient pour optimiser le coût et obtenir les valeurs optimales de $\\Theta$.\nIl est possible d\u0026rsquo;avoir les valeurs exactes de $\\Theta$ (celle qui minimisent le coût) en utilisant l\u0026rsquo;équation normale: $$ \\theta = \\left( X^TX \\right)^{-1}X^TY $$ Vous trouverez sur ce gist une implémentation basique de la solution réalisée avec Gonum.\n Génération des données d\u0026rsquo;entrainement avec gota (dataframe) Tout d\u0026rsquo;abord, générons les données d\u0026rsquo;entrainement. Nous utiliserons un dataframe pour nous simplifier la tâche.\nCe howto donne plus d\u0026rsquo;information sur l\u0026rsquo;utilisation du dataframe\n func getXYMat() (*mat.Dense, *mat.Dense) { f, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) xDF := df.Drop(\u0026#34;species\u0026#34;) toValue := func(s series.Series) series.Series { records := s.Records() floats := make([]float64, len(records)) for i, r := range records { switch r { case \u0026#34;setosa\u0026#34;: floats[i] = 1 case \u0026#34;virginica\u0026#34;: floats[i] = 2 case \u0026#34;versicolor\u0026#34;: floats[i] = 3 default: log.Fatalf(\u0026#34;unknown iris: %v\\n\u0026#34;, r) } } return series.Floats(floats) } yDF := df.Select(\u0026#34;species\u0026#34;).Capply(toValue) numRows, _ := xDF.Dims() xDF = xDF.Mutate(series.New(one(numRows), series.Float, \u0026#34;bias\u0026#34;)) fmt.Println(xDF.Describe()) fmt.Println(yDF.Describe()) return mat.DenseCopyOf(\u0026amp;matrix{xDF}), mat.DenseCopyOf(\u0026amp;matrix{yDF}) } Cette fonction retourne deux matrices que nous pourrons utiliser avec Gorgonia.\nCreation de l\u0026rsquo;ExprGrap L\u0026rsquo;équation $X\\cdot\\Theta$ est encodée en tant qu\u0026rsquo;ExprGraph:\nfunc getXY() (*tensor.Dense, *tensor.Dense) { x, y := getXYMat() xT := tensor.FromMat64(x) yT := tensor.FromMat64(y) // Get rid of the last dimension to create a vector \ts := yT.Shape() yT.Reshape(s[0]) return xT, yT } func main() { xT, yT := getXY() g := gorgonia.NewGraph() x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y := gorgonia.NodeFromAny(g, yT, gorgonia.WithName(\u0026#34;y\u0026#34;)) theta := gorgonia.NewVector( g, gorgonia.Float64, gorgonia.WithName(\u0026#34;theta\u0026#34;), gorgonia.WithShape(xT.Shape()[1]), gorgonia.WithInit(gorgonia.Uniform(0, 1))) pred := must(gorgonia.Mul(x, theta)) // Saving the value for later use  var predicted gorgonia.Value gorgonia.Read(pred, \u0026amp;predicted) Gorgonia est très optimisé; il fait utilise beaucoup les pointeurs pour optimiser son empreinte mémoire. Par conséquemt, appeler la méthode Value() d\u0026rsquo;un *Node pendant la phase d\u0026rsquo;exécution du graphe, peut produire des résultats incorrects. Pour accéder à la valeur contenue dans un *Node (pendant la phase d\u0026rsquo;apprentissage par exemple), il est nécessaire de garder une référence pointant sur ladite valeur. C\u0026rsquo;est la raison pour laquelle nous utilisons la méthode Read. predicted contient une référence à la valeur résultante de l\u0026rsquo;opération $X\\cdot\\Theta$.\n Préparation du calcul du gradient Nous allons utiliser la fonctionnalité de Gorgonia: Symbolic differentiation.\nTout d\u0026rsquo;abord, nous allons créer une fonction de coût, puis utiliser un solver pour faire la descente de gradient.\nCreation du \u0026ldquo;node\u0026rdquo; qui contiendra le coût de l\u0026rsquo;équation Completons à présent l\u0026rsquo;exprgraph en ajoutant le coût (pour rappel, $cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$)\nsquaredError := must(gorgonia.Square(must(gorgonia.Sub(pred, y)))) cost := must(gorgonia.Mean(squaredError)) Notre but est de minimiser ce coût. Nous allons donc calculer le gradient de la fonction par rapport à $\\Theta$:\nif _, err := gorgonia.Grad(cost, theta); err != nil { log.Fatalf(\u0026#34;Failed to backpropagate: %v\u0026#34;, err) } La descente du gradient Nous utilisons le principe de descente de gradient. Ceci signifie que nous utilisons le gradient de la fonction pour altérer le paramètre $\\Theta$ pas à pas.\nUne implémentation basique de descente de gradient est implémentée dans le Vanilla Solver de Gorgonia. Nous positionnons le \u0026ldquo;pas\u0026rdquo; $\\gamma$ à 0.001.\nsolver := gorgonia.NewVanillaSolver(gorgonia.WithLearnRate(0.001)) À chaque étape, nous allons demander au solver de mettre à jour $\\Theta$ grâce au gradient. Par conséquent, nous assignons une variable update que nous allons passer au solver à chaque itération.\nLa descente de gradient va mettre à jour toutes les valeurs présentes dans le tableau []gorgonia.ValueGrad à chqaue étape suivant cette équation: ${\\displaystyle x^{(k+1)}=x^{(k)}-\\gamma \\nabla f\\left(x^{(k)}\\right)}$ Il est important de comprendre que le solver travaille sur des Values et non des Nodes. Cependant, afin de simplifier les choses, l\u0026rsquo;interface ValueGrad est implémenté par la structure *Node.\n Dans notre cas, nous voulons trouver les valeurs de $\\Theta$; nous demandons au solver de mettre à jour la valeur en suivant cette équation:\n${\\displaystyle \\Theta^{(k+1)}=\\Theta^{(k)}-\\gamma \\nabla f\\left(\\Theta^{(k)}\\right)}$\nLe solver se charge d\u0026rsquo;implémenter l\u0026rsquo;équation. Nous devons simplement passer $\\Theta$ a chaque Step du Solver:\nupdate := []gorgonia.ValueGrad{theta} // ... if err = solver.Step(update); err != nil { log.Fatal(err) } L\u0026rsquo;apprentissage À présent que la mécanique est en place, nous devons lancer le calcul grâce à une vm. Ce calcul doit être lancé un grand nombre de fois pour que la descente de gradient puisse agir.\nCréons à présent une vm pour lancer le calcul.\nmachine := gorgonia.NewTapeMachine(g, gorgonia.BindDualValues(theta)) defer machine.Close() Nous demandons au solver de mettre à jour le paramètre $\\Theta$ par rapport au gradient. Par conséquent nous devons dire à la TapeMachine de stocker la valeur de $\\Theta$ ainsi que sa dérivée (sa dual value) Ceci est la raison de l\u0026rsquo;utilisation de la fonction BindDualValues.\n Maintenant nous pouvons créer une boucle et calculer le graphe étape par étape; la machine va apprendre!\niter := 1000000 var err error for i := 0; i \u0026lt; iter; i++ { if err = machine.RunAll(); err != nil { fmt.Printf(\u0026#34;Error during iteration: %v: %v\\n\u0026#34;, i, err) break } if err = solver.Step(model); err != nil { log.Fatal(err) } machine.Reset() // Reset is necessary in a loop like this } Afficer des informations Nous pouvons afficher des informations sur le processus d\u0026rsquo;apprentissage en utilisant cet appel:\nfmt.Printf(\u0026#34;theta: %2.2f Iter: %v Cost: %2.3f Accuracy: %2.2f \\r\u0026#34;, theta.Value(), i, cost.Value(), accuracy(predicted.Data().([]float64), y.Value().Data().([]float64))) Avec la fonction accuracy définie de la manière suivante:\nfunc accuracy(prediction, y []float64) float64 { var ok float64 for i := 0; i \u0026lt; len(prediction); i++ { if math.Round(prediction[i]-y[i]) == 0 { ok += 1.0 } } return ok / float64(len(y)) } Ceci affichera une ligne semblable à celle ci pendant la phase d\u0026rsquo;apprentissage:\ntheta: [ 0.26 -0.41 0.44 -0.62 0.83] Iter: 26075 Cost: 0.339 Accuracy: 0.61 Sauvegarde des données Une fois l\u0026rsquo;entrainement terminé, nous pouvons sauvegarder les valeurs de $\\Theta$ pour pouvoir les utiliser dans des prédictions:\nfunc save(value gorgonia.Value) error { f, err := os.Create(\u0026#34;theta.bin\u0026#34;) if err != nil { return err } defer f.Close() enc := gob.NewEncoder(f) err = enc.Encode(value) if err != nil { return err } return nil } Création d\u0026rsquo;un utilitaire CLI Nous allons à présent créer un utilitaire qui va permettre de donner l\u0026rsquo;espèce d\u0026rsquo;une fleur en fonction des paramètres d\u0026rsquo;entrée.\nTout d\u0026rsquo;abord, chargeons les paramètres que nous venons de sauvegarder lors de la phase d\u0026rsquo;entrainement.\nfunc main() { f, err := os.Open(\u0026#34;theta.bin\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() dec := gob.NewDecoder(f) var thetaT *tensor.Dense err = dec.Decode(\u0026amp;thetaT) if err != nil { log.Fatal(err) } Ensuite, créeons le modèle (l\u0026rsquo;exprgraph) d\u0026rsquo;une manière semblable à ce que nous avons fait auparavant:\nDans un développement logiciel, il serait probablement souhaitable de partager ce code entre les deux outils (training et execution) en l\u0026rsquo;isolant dans un package.\n g := gorgonia.NewGraph() theta := gorgonia.NodeFromAny(g, thetaT, gorgonia.WithName(\u0026#34;theta\u0026#34;)) values := make([]float64, 5) xT := tensor.New(tensor.WithBacking(values)) x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y, err := gorgonia.Mul(x, theta) Ensuite nous executons une boucle infinie pendant laquelle nous allons demander les infos, calculer et afficher le résultat:\nmachine := gorgonia.NewTapeMachine(g) values[4] = 1.0 for { values[0] = getInput(\u0026#34;sepal length\u0026#34;) values[1] = getInput(\u0026#34;sepal widt\u0026#34;) values[2] = getInput(\u0026#34;petal length\u0026#34;) values[3] = getInput(\u0026#34;petal width\u0026#34;) if err = machine.RunAll(); err != nil { log.Fatal(err) } switch math.Round(y.Value().Data().(float64)) { case 1: fmt.Println(\u0026#34;It is probably a setosa\u0026#34;) case 2: fmt.Println(\u0026#34;It is probably a virginica\u0026#34;) case 3: fmt.Println(\u0026#34;It is probably a versicolor\u0026#34;) default: fmt.Println(\u0026#34;unknown iris\u0026#34;) } machine.Reset() } Voici une fonction utilitaire pour récupérer les entrées:\nfunc getInput(s string) float64 { reader := bufio.NewReader(os.Stdin) fmt.Printf(\u0026#34;%v: \u0026#34;, s) text, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) text = strings.Replace(text, \u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;, -1) input, err := strconv.ParseFloat(text, 64) if err != nil { log.Fatal(err) } return input } Il ne reste plus qu\u0026rsquo;à \u0026ldquo;builder\u0026rdquo; le code et voilà! Nous avons un utilitaire autonome capable de prédire l\u0026rsquo;espèce d\u0026rsquo;une Irir en fonction de ses attributs:\n$ go run main.go sepal length: 4.4 sepal widt: 2.9 petal length: 1.4 petal width: 0.2 It is probably a setosa sepal length: 5.9 sepal widt: 3.0 petal length: 5.1 petal width: 1.8 It is probably a virginica Conclusion Dans cet exemple pas-à-pas, nous avons construit un logiciel complet.\nÀ présent vous pouvez poursuivre les tests en changeant les valeurs initiales de $\\Theta$ ou en utilisant un autre solver fournit par Gorgonia.\nLe code complet de ce tutoriel est présent dans le répertoire examples des sources de Gorgonia.\nBonus: visual representation Il est possible de visualiser le dataset en utilisant la bibliothèque plotter du projet Gonum. Voici un exemple.\nimport ( \u0026#34;gonum.org/v1/plot\u0026#34; \u0026#34;gonum.org/v1/plot/plotter\u0026#34; \u0026#34;gonum.org/v1/plot/plotutil\u0026#34; \u0026#34;gonum.org/v1/plot/vg\u0026#34; \u0026#34;gonum.org/v1/plot/vg/draw\u0026#34; ) func plotData(x []float64, a []float64) []byte { p, err := plot.New() if err != nil { log.Fatal(err) } p.Title.Text = \u0026#34;sepal length \u0026amp; width\u0026#34; p.X.Label.Text = \u0026#34;length\u0026#34; p.Y.Label.Text = \u0026#34;width\u0026#34; p.Add(plotter.NewGrid()) l := len(x) / len(a) for k := 1; k \u0026lt;= 3; k++ { data0 := make(plotter.XYs, 0) for i := 0; i \u0026lt; len(a); i++ { if k != int(a[i]) { continue } x1 := x[i*l+0] // sepal_length \ty1 := x[i*l+1] // sepal_width \tdata0 = append(data0, plotter.XY{X: x1, Y: y1}) } data, err := plotter.NewScatter(data0) if err != nil { log.Fatal(err) } data.GlyphStyle.Color = plotutil.Color(k - 1) data.Shape = \u0026amp;draw.PyramidGlyph{} p.Add(data) p.Legend.Add(fmt.Sprint(k), data) } w, err := p.WriterTo(4*vg.Inch, 4*vg.Inch, \u0026#34;png\u0026#34;) if err != nil { panic(err) } var b bytes.Buffer writer := bufio.NewWriter(\u0026amp;b) w.WriteTo(writer) ioutil.WriteFile(\u0026#34;out.png\u0026#34;, b.Bytes(), 0644) return b.Bytes() }"},{"uri":"/fr/how-to/dataframe/","title":"Créer un tensor depuis un Dataframe (gota)","tags":[],"description":"","content":" Cet article explique comment créer un tenseur depuis un dataframe en utilisant le package gota.\nLe but est de lire un fichier csv et de créer un objet *tensor.Dense de forme (2,2).\nCreation du dataframe depuis le fichier csv Considerons un ficier csv avec le contenu suivant:\nsepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... Ceci est un extrait du Iris flower data set. Une copie du dataset peut être téléchargée ici\n Nous voulons créer un tenseur qui contient toutes les valeurs sauf la colonne \u0026ldquo;species\u0026rdquo;.\nCreation du dataframe avec gota le package dataframe de gota propose une fonction ReadCSV qui prend pour argument un io.Reader.\nf, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) df est un DataFrame qui remferme toutes les données présentes dans le fichier.\ngota utilise la première ligne du fichier csv pour référencer les colonnes dans le dataframe\n Supprimons à présent la colonne species du dataframe:\nxDF := df.Drop(\u0026#34;species\u0026#34;) Conversion du dataframe vers une matrice Pour simplifier les choses, nous allons convertir le dataframe en une Matrix telle que définie dans le package gonum (cf la godoc de Matrix). Matrix est une interface. Cependant, la structure Dataframe de gota ne remplit pas le contrat d\u0026rsquo;interface Matrix Nous allons donc encapsuler l\u0026rsquo;objet dans une structure de plus haut niveau et nous allons implémenter les fonctions nécessaire au contrat d\u0026rsquo;interface telle que décrit dans la documentation de gota:\ntype matrix struct { dataframe.DataFrame } func (m matrix) At(i, j int) float64 { return m.Elem(i, j).Float() } func (m matrix) T() mat.Matrix { return mat.Transpose{Matrix: m} } Creation du tenseur Nous pouvons à présent créer un tenseur *Dense grâce à la fonction tensor.FromMat64 du package tensor en encapsulant le dataframe dans la structure matrix.\nxT := tensor.FromMat64(mat.DenseCopyOf(\u0026amp;matrix{xDF}))"},{"uri":"/fr/how-to/","title":"How-tos","tags":[],"description":"","content":""},{"uri":"/fr/","title":"Gorgonia","tags":[],"description":"","content":" Gorgonia Gorgonia est une bibliothèque qui facilite la mise en place de mécanismes de machine learning en Go.\nElle permet d\u0026rsquo;écrire et de calculer des équations mathématiques utilisant des tableaux à multiples dimensions.\nDans l\u0026rsquo;idée, cette bibliothèque est semblable à Theano et TensorFlow.\nD\u0026rsquo;une manière générale, cette bibliothèque est relativement bas-niveau, comme Theano, mais possède des objectifs plus ambitieux comme TensorFlow.\nPourquoi utiliser Gorgonia ? La cible principale de Gorgonia est de rendre l\u0026rsquo;expérience du développeur agréable. So vous êtes un Gopher, grâce à Gorgonia, vous avez la possibilité de créer des systèmes utilisant le machine learning qui soient \u0026ldquo;production-ready\u0026rdquo;.\nLe développement en IA/ML est généralement divisé en deux étapes:\n Les expériences pendant lesquels sont conçus les modèles, et pendant lesquels beaucoup de tests sont réalisés. La phase de déploiement pendant laquelle les modèles sont industrialisés pour être opérés à l\u0026rsquo;échelle.  Ces différentes phases sont associées à divers métiers tels que data-scientiste ou data-ingénieur.\nD\u0026rsquo;une manière générale, ces deux étapes ne sont pas réalisées en utilisant les mêmes outils:\n Python/Lua (et les frameworks de type Theano, Torch, etc), sont couramment utilisés dans les phases d\u0026rsquo;expérimentation. Durant les phases d\u0026rsquo;exploitation et de déploiement, le modèle est en général réécrit dans un langage plus performant tel que le C++. (en utilisant par exemple dlib, mlpack etc).  Bien entendu, de nos jours, l\u0026rsquo;écart de performance entre les outils se réduit, ce qui aboutit à un partage des outils entre les différentes phases. TensorFlow est un exemple d\u0026rsquo;outil qui est utilisé dans les deux étapes du développement et qui opère comme un pont entre deux.\nLe but de Gorgonia est le même, mais dans l\u0026rsquo;écosystème Go. Gorgonia est performant. Sa vitesse d\u0026rsquo;exécution sur CPU est comparable à Theano et TensorFlow. Les implémentations GPU sont plus délicates à comparer dû à la charge induite par l\u0026rsquo;utilisation de CGO. Cette partie est en développement actif.\nOrganisation de ce site web Ce site web est composé de 4 sections ayant différents objectifs:\n Premiers pas  Démarrer rapidement avec Gorgonia\n Tutoriels  Tutoriels sur quelques cas d\u0026#39;usage\n How-tos  \n "},{"uri":"/fr/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"/fr/tags/","title":"Tags","tags":[],"description":"","content":""}]
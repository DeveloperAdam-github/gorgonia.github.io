[{"uri":"/tutorials/hello-world/","title":"Hello World","tags":[],"description":"","content":" This is a step by step tutorial to do a very simple computation with Gorgonia.\nOur goal is to use all the plumbing of Gorgonia to do a simple operation:\n$ f(x,y) = x + y $\nwith x = 2 and y = 5\nhow it works The equation x + y = z can be represented as a graph:\ngraph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y  To compute the result, we use 4 steps:\n Make a similar graph with Gorgonia sets some values on the nodes x and y then instanciate a graph on a gorgonia vm extract the value from node z *  Create a graph Create an empty expression graph with this method:\ng := gorgonia.NewGraph() Create the nodes We will create some nodes and associate them to the ExprGraph.\nvar x, y, z *gorgonia.Node Create the placeholder x and y are scalar variables, we can create the corresponding node with:\nx = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) the functions take the exprgraph as argument; the resulting node is automatically associated to the graph.\n Now create the addition operator; this operator takes two nodes and returns a new node z:\nif z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) }  the returning node z is added to the graph even if g is not passed to z or to the Add function.\n Set the values We have a ExprGraph that represents the equation z = x + y. Now it\u0026rsquo;s time to assign some values to x and y.\nWe use the Let function:\ngorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) Run the graph To run the graph and compute the result, we need to instanciate a VM. Let\u0026rsquo;s use the TapeMachine:\nmachine := gorgonia.NewTapeMachine(g) defer machine.Close() and run the graph:\nif err = machine.RunAll(); err != nil { log.Fatal(err) } If a second run is needed, it is mandatory to call the Reset() method of the vm object: machine.Reset()\n Get the result Now the node z holds the result. We can extract its value by calling the Value() method:\nfmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) we could also access the underlying \u0026ldquo;Go\u0026rdquo; value with a call to z.Value().Data() which would return an interface{} holding a float64 in our case\n Final result package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) }$ go run main.go 4.5"},{"uri":"/tutorials/hello-world.jp/","title":"こんにちわ世界","tags":[],"description":"","content":" これはGorgoniaでとても簡単な計算を行うための段階的なチュートリアルです。\n私たちのゴールはGorgoniaのすべての配管を使用して簡単な操作を行うことです:\n$ f(x,y) = x + y $\nwith x = 2 and y = 5\nどの様に動作するか x + y = z の評価はグラフで表す事ができます:\ngraph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y  結果を計算する為に4つのステップを使います:\n Make a similar graph with Gorgonia sets some values on the nodes x and y then instanciate a graph on a gorgonia vm extract the value from node z *  Create a graph Create an empty expression graph with this method:\ng := gorgonia.NewGraph() Create the nodes We will create some nodes and associate them to the ExprGraph.\nvar x, y, z *gorgonia.Node Create the placeholder x and y are scalar variables, we can create the corresponding node with:\nx = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) the functions take the exprgraph as argument; the resulting node is automatically associated to the graph.\n Now create the addition operator; this operator takes two nodes and returns a new node z:\nif z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) }  the returning node z is added to the graph even if g is not passed to z or to the Add function.\n Set the values We have a ExprGraph that represents the equation z = x + y. Now it\u0026rsquo;s time to assign some values to x and y.\nWe use the Let function:\ngorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) Run the graph To run the graph and compute the result, we need to instanciate a VM. Let\u0026rsquo;s use the TapeMachine:\nmachine := gorgonia.NewTapeMachine(g) defer machine.Close() and run the graph:\nif err = machine.RunAll(); err != nil { log.Fatal(err) } 2回目の実行が必要な場合vmオブジェクトのReset()メソッドを呼び出すことが必須です: machine.Reset()\n 値の取得 これでノードzが結果を保持します。 Valueを抽出するにはValue()メソッドを呼び出します:\nfmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) この場合float64を保持するinterface{}を返すz.Value().Data()を呼び出して、基になる\u0026rdquo;Go\u0026rdquo;値にアクセスすることもできます。\n 最終結果 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) }$ go run main.go 4.5"},{"uri":"/getting-started/","title":"事始め","tags":[],"description":"","content":" Gorgoniaの入手 Gorgoniaはgo-get可能でありgo modulesをサポートしています。 ライブラリとその依存物を取得するには単純に以下を実行します。\n$ go get gorgonia.org/gorgonia 簡単な計算をする為の初めてのコード 配管が正常かどうかを確認する簡単なプログラムを作成します:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) } プログラムを実行するとこの結果が出力されるはずです： 4.5\n詳細についてはHello Worldチュートリアルを参照してください。\n"},{"uri":"/about/_index.jp/","title":"Gorgoniaの仕組み","tags":[],"description":"","content":"このセクションにはGorgoniaの仕組みを説明することを目的とした記事が含まれています。\nこのセクションの記事は次のとおり:\n 理解志向である 背景とコンテキストを提供  類似品: 料理の社会史に関する記事\n"},{"uri":"/tutorials/_index.jp/","title":"チュートリアル","tags":[],"description":"","content":"Gorgoniaのさまざまな使われ方を試し始める為のさまざまなチュートリアル。\nこのチュートリアルは:\n 学習指向 新たな人でも始められる 1つずつのレッスン  類似品: 子供に料理の仕方を教える方法\n"},{"uri":"/how-to/_index.jp/","title":"ハウツー","tags":[],"description":"","content":"Gorgoniaでさまざまな機械学習を行う方法。\nこのセクションではGorgoniaを使用してさまざまな問題を解決する方法を説明します。\n以下の様なハウツーガイドです:\n 目標指向 特定の問題を解決する方法を示します 理解可能な手順で構成します  類似品：料理本のレシピ\n"},{"uri":"/reference/","title":"Reference guide","tags":[],"description":"","content":"This is the reference guide of Gorgonia. The goal of the articles in this section are:\n being information-oriented describing the machinery being accurate and complete  Analogy: a reference encyclopaedia article\n"},{"uri":"/how-to/dataframe/","title":"Create a tensor from a Dataframe (gota)","tags":[],"description":"","content":" This howto explains how to create a tensor from a dataframe using gota The goal is to read a csv file and create a *tensor.Dense with shape (2,2).\nCreate the dataframe from a csv file Consider a csv file with the following content:\nsepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... This is extract from the Iris flower data set. A copy of the dataset can be found here\n We want to create a tensor with all values but the species.\nCreate the dataframe with gota. gota\u0026rsquo;s dataframe package has a function ReadCSV that takes an io.Reader as argument.\nf, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) df is a DataFrame that contains all the data present in the file.\ngota uses te first line of the CSV to reference the columns in the dataframe\n Let\u0026rsquo;s remove the species column:\nxDF := df.Drop(\u0026#34;species\u0026#34;) Convert the dataframe into a matrix To make things easier, we will convert our dataframe into a Matrix as defined by gonum (see the matrix godoc). matrix is an interface. gota\u0026rsquo;s dataframe does not fulfill the Matrix interface. As described into gota\u0026rsquo;s documentation, we create a wrapper around DataFrame to fulfil the Matrix interface.\ntype matrix struct { dataframe.DataFrame } func (m matrix) At(i, j int) float64 { return m.Elem(i, j).Float() } func (m matrix) T() mat.Matrix { return mat.Transpose{Matrix: m} } Create the tensor Now we can create a *Dense tensor thanks to the function tensor.FromMat64 by wrapping the dataframe into the matrix structure.\nxT := tensor.FromMat64(mat.DenseCopyOf(\u0026amp;matrix{xDF}))"},{"uri":"/","title":"Gorgonia","tags":[],"description":"","content":""},{"uri":"/how-to/","title":"How-tos","tags":[],"description":"","content":""},{"uri":"/how-to/dataframe.jp/","title":"データフレームからテンソルを作成 (gota)","tags":[],"description":"","content":" このハウツーでは、gotaを使用してデータフレームからテンソルを作成する方法を説明します。 The goal is to read a csv file and create a *tensor.Dense with shape (2,2). ゴールは、csvファイルを読み取り、(2,2) のシェイプの* tensor.Denseを作成することです。\ncsvファイルからデータフレームを作成する 以下のコンテンツのcsvファイルを考えます:\nsepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... これはIris flower data setからの抜粋です。 データセットのコピーはここから見つける事ができます。\n 種別以外のすべての値を含むテンソルを作成します。\ngotaを使用してデータフレームを作成する gotaのデータフレームパッケージにはio.Readerを引数として取る関数ReadCSVがあります。\nf, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) dfがファイルに存在する全てのデータが含まれるDataFrameです。\ngotaはデータフレームの列を参照する為にCSVの最初の行を使用します。\n 種別(species)カラムを削除しましょう:\nxDF := df.Drop(\u0026#34;species\u0026#34;) データフレームを行列に変換する To make things easier, we will convert our dataframe into a Matrix as defined by gonum (see the matrix godoc). 物事を簡単にするために、データフレームをgonumで定義されているMatrixに変換します(matrixのgodocを参照)。 matrixはインタフェースです。gotaのデータフレームはMatrixインターフェイスを満たしません。gotaのドキュメントに記載されているように、 Matrixインターフェイスを満たすために、データフレームのラッパーを作成します。\ntype matrix struct { dataframe.DataFrame } func (m matrix) At(i, j int) float64 { return m.Elem(i, j).Float() } func (m matrix) T() mat.Matrix { return mat.Transpose{Matrix: m} } テンソルを作る データフレームをmatrix構造体の中にラッピングすると関数tensor.FromMat64のおかげで*Denseテンソルを作成できるようになります。\nxT := tensor.FromMat64(mat.DenseCopyOf(\u0026amp;matrix{xDF}))"},{"uri":"/reference/tensor/","title":"Tensor","tags":[],"description":"","content":""},{"uri":"/reference/solver/","title":"Solvers","tags":[],"description":"","content":""},{"uri":"/tutorials/","title":"Tutorials","tags":[],"description":"","content":""},{"uri":"/_index.jp/","title":"main","tags":[],"description":"","content":" Gorgonia GorgoniaはGoでの機械学習を楽にするためのライブラリです。\n多次元配列を含む数式を簡単に記述して評価します。\nTheanoまたはTensorFlowに似た物の様に感じるかもしれませんが場合、それはアイデアが非常に似ているためです。\n具体的にはライブラリはTheanoのようにかなり低レベルですが、Tensorflowの様なより高い目標を持っています。\nなぜGorgoniaを使うのか? Gorgoniaを使用する主な理由は開発者を楽にする事です。Goスタックを広範囲に使用しているのであれば使い慣れた環境で実稼働対応の機械学習システムを作成する機能にアクセスできます。\n大儀ではML/AIは2つのステージに分類されます。1つはさまざまなモデルを構築しテストと再テストを行う実験のステージ。またテストを実施し実際に試され、デプロイされた後のモデルがあるステージ。これらはデータサイエンティストとデータエンジニアのように異なる役割を必要とします。\n通常、2つのフェーズには異なるツールが存在します。Python/Lua（Theano、Torchなどを使用)が一般的に使用されます 実験の段階では、C++(dlib、mlpack等より高性能な言語でモデルが書き換えられます)。もちろん今日では格差は縮まりつつあり、人々は頻繁にツールを共有しています。 Tensorflowはこのギャップを埋めるツールの1つです。\nGorgoniaは同じ場所を目指していますがGo環境を提供します。Gorgoniaは現在とても良い性能を発揮します - その速度はTheanoとTensorflowのCPU実装に匹敵します。 GPUの実装はcgoの負担が重いため比較するには多少手間がかかりますが、これらは現在、積極的に改善を行っている領域ですのでご安心ください。\nこのウェブサイトの構成は? このウェブサイトはさまざまなゴールを持つ4つのセクションで構成されています:\n はじめに Gorgoniaの仕組みに関する全ての情報が含まれます リファレンス ハウツー チュートリアル  "},{"uri":"/reference/vm/","title":"VM","tags":[],"description":"","content":""},{"uri":"/about/","title":"Abouts","tags":[],"description":"","content":""},{"uri":"/cu/","title":"CU","tags":[],"description":"","content":""},{"uri":"/dawson/","title":"Dawson","tags":[],"description":"","content":""},{"uri":"/golgi/","title":"Golgi","tags":[],"description":"","content":""},{"uri":"/gorgonia/","title":"Gorgonia","tags":[],"description":"","content":""},{"uri":"/randomkit/","title":"RandomKit","tags":[],"description":"","content":""},{"uri":"/tensor/","title":"Tensor","tags":[],"description":"","content":""},{"uri":"/vanity-import-paths/","title":"Vanity-import-paths","tags":[],"description":"","content":""},{"uri":"/vecf32/","title":"vecf32","tags":[],"description":"","content":""},{"uri":"/vecf64/","title":"vecf64","tags":[],"description":"","content":""},{"uri":"/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"/tags/","title":"Tags","tags":[],"description":"","content":""}]
[{"uri":"/jp/tutorials/hello-world/","title":"こんにちわ世界","tags":[],"description":"","content":" これはGorgoniaでとても簡単な計算を行うための段階的なチュートリアルです。\n私たちのゴールはGorgoniaのすべての配管を使用して簡単な操作を行うことです:\n$ f(x,y) = x + y $\nwith x = 2 and y = 5\nどの様に動作するか x + y = z の評価はグラフで表す事ができます:\ngraph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y  結果を計算する為に4つのステップを使います:\n Make a similar graph with Gorgonia sets some values on the nodes x and y then instanciate a graph on a gorgonia vm extract the value from node z *  Create a graph Create an empty expression graph with this method:\ng := gorgonia.NewGraph() Create the nodes We will create some nodes and associate them to the ExprGraph.\nvar x, y, z *gorgonia.Node Create the placeholder x and y are scalar variables, we can create the corresponding node with:\nx = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) the functions take the exprgraph as argument; the resulting node is automatically associated to the graph.\n Now create the addition operator; this operator takes two nodes and returns a new node z:\nif z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) }  the returning node z is added to the graph even if g is not passed to z or to the Add function.\n Set the values We have a ExprGraph that represents the equation z = x + y. Now it\u0026rsquo;s time to assign some values to x and y.\nWe use the Let function:\ngorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) Run the graph To run the graph and compute the result, we need to instanciate a VM. Let\u0026rsquo;s use the TapeMachine:\nmachine := gorgonia.NewTapeMachine(g) defer machine.Close() and run the graph:\nif err = machine.RunAll(); err != nil { log.Fatal(err) } 2回目の実行が必要な場合vmオブジェクトのReset()メソッドを呼び出すことが必須です: machine.Reset()\n 値の取得 これでノードzが結果を保持します。 Valueを抽出するにはValue()メソッドを呼び出します:\nfmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) この場合float64を保持するinterface{}を返すz.Value().Data()を呼び出して、基になる\u0026rdquo;Go\u0026rdquo;値にアクセスすることもできます。\n 最終結果 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) }$ go run main.go 4.5"},{"uri":"/jp/getting-started/","title":"事始め","tags":[],"description":"","content":" Gorgoniaの入手 Gorgoniaはgo-get可能でありgo modulesをサポートしています。 ライブラリとその依存物を取得するには単純に以下を実行します。\n$ go get gorgonia.org/gorgonia 簡単な計算をする為の初めてのコード 配管が正常かどうかを確認する簡単なプログラムを作成します:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) } プログラムを実行するとこの結果が出力されるはずです： 4.5\n詳細についてはHello Worldチュートリアルを参照してください。\n"},{"uri":"/jp/about/","title":"Gorgoniaの仕組み","tags":[],"description":"","content":"このセクションにはGorgoniaの仕組みを説明することを目的とした記事が含まれています。\nこのセクションの記事は次の通り:\n 理解志向である 背景とコンテキストを提供  類似品: 料理の社会史に関する記事\n"},{"uri":"/jp/tutorials/","title":"チュートリアル","tags":[],"description":"","content":"Gorgoniaのさまざまな使われ方を試し始める為のさまざまなチュートリアル。\nこのチュートリアルは:\n 学習指向 新たな人でも始められる 1つずつのレッスン  類似品: 子供に料理の仕方を教える方法\n"},{"uri":"/jp/how-to/","title":"ハウツー","tags":[],"description":"","content":"Gorgoniaでさまざまな機械学習を行う方法。\nこのセクションではGorgoniaを使用してさまざまな問題を解決する方法を説明します。\n以下の様なハウツーガイドです:\n 目標指向 特定の問題を解決する方法を示します 理解可能な手順で構成します  類似品：料理本のレシピ\n"},{"uri":"/jp/tutorials/iris/","title":"Iris データセットでの多変量線形回帰","tags":[],"description":"","content":" About Gorgoniaを使用して線形回帰モデルを作成します。\nゴールは以下に与えられた特性を考慮して花の種別を予測することです:\n sepal_length sepal_width petal_length petal_width  存在する種別は以下の通り:\n setosa virginica versicolor  このチュートリアルのゴールはgorgoniaを使用して、与えられたirisデータセットから $\\Theta$ の正しい値を見つけ以下のようなcliユーティリティを作成することです:\n./iris sepal length: 5 sepal width: 3.5 petal length: 1.4 sepal length: 0.2 It is probably a setosa このチュートリアルは学術目的の為の物です。Gorgoniaでこれをどの様にして行うかを説明することがゴールです; これは特定の問題に対する最先端の答えではありません。\n Mathematical representation 良くある花弁の長さと幅だけでなく、がく片の長さと幅の関数であった場合とその種別について考察します。\nしたがって $y$ が種別の値であると考える場合に解決すべき方程式は次の通りです:\n$$ y = \\theta_0 + \\theta_1 * sepal\\_length + \\theta_2 * sepal\\_width + \\theta_3 * petal\\_length + \\theta_4 * petal\\_width$$\nif we consider the vectors $x$ and $\\Theta$ such as:\n$$ x = \\begin{bmatrix} sepal\\_length \u0026amp; sepal\\_width \u0026amp; petal\\_length \u0026amp; petal\\_width \u0026amp; 1\\end{bmatrix}$$\n$$ \\Theta = \\begin{bmatrix} \\theta_4 \\theta_3 \\theta_2 \\theta_1 \\theta_0 \\end{bmatrix} $$\nよってこうなります。\n$$y = x\\cdot\\Theta$$\nLinear regression 正しい値を見つける為に線形回帰を使用します。 データを5列(がく片の長さ、がく片の幅、花弁の長さ、花弁の幅、およびバイアスの1)を含む行列 $X$ にエンコードします。 行列の行は種別を表します。\n対応する種別をfloat値を持つ列ベクトル $Y$ にエンコードします。\n setosa = 1.0 virginica = 2.0 versicolor = 3.0  学習段階ではコストは次のように表す事ができます:\n$cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$\n勾配降下法を使用してコストを下げ $\\ Theta$ の正確な値を取得します\nIt is possible to get the exact $\\theta$ values with the Normal Equation $$ \\theta = \\left( X^TX \\right)^{-1}X^TY $$ See this gist for a basic implementation with gonum.\n gota(データフレーム)を使用してトレーニングセットを生成する まずトレーニングデータを生成しましょう。データフレームを使用してスムーズに行います。\nデータフレームの使用方法やその他の情報についてはhowtoを参照\n func getXYMat() (*mat.Dense, *mat.Dense) { f, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) xDF := df.Drop(\u0026#34;species\u0026#34;) toValue := func(s series.Series) series.Series { records := s.Records() floats := make([]float64, len(records)) for i, r := range records { switch r { case \u0026#34;setosa\u0026#34;: floats[i] = 1 case \u0026#34;virginica\u0026#34;: floats[i] = 2 case \u0026#34;versicolor\u0026#34;: floats[i] = 3 default: log.Fatalf(\u0026#34;unknown iris: %v\\n\u0026#34;, r) } } return series.Floats(floats) } yDF := df.Select(\u0026#34;species\u0026#34;).Capply(toValue) numRows, _ := xDF.Dims() xDF = xDF.Mutate(series.New(one(numRows), series.Float, \u0026#34;bias\u0026#34;)) fmt.Println(xDF.Describe()) fmt.Println(yDF.Describe()) return mat.DenseCopyOf(\u0026amp;matrix{xDF}), mat.DenseCopyOf(\u0026amp;matrix{yDF}) } Gorgoniaで使用できる2つの行列を返します。\nCreate the expression graph 方程式 $X\\cdot\\Theta$ は ExprGraph として表されます:\nfunc getXY() (*tensor.Dense, *tensor.Dense) { x, y := getXYMat() xT := tensor.FromMat64(x) yT := tensor.FromMat64(y) // Get rid of the last dimension to create a vector \ts := yT.Shape() yT.Reshape(s[0]) return xT, yT } func main() { xT, yT := getXY() g := gorgonia.NewGraph() x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y := gorgonia.NodeFromAny(g, yT, gorgonia.WithName(\u0026#34;y\u0026#34;)) theta := gorgonia.NewVector( g, gorgonia.Float64, gorgonia.WithName(\u0026#34;theta\u0026#34;), gorgonia.WithShape(xT.Shape()[1]), gorgonia.WithInit(gorgonia.Uniform(0, 1))) pred := must(gorgonia.Mul(x, theta)) // Saving the value for later use  var predicted gorgonia.Value gorgonia.Read(pred, \u0026amp;predicted) Gorgoniaは高度に最適化されています。良いパフォーマンスを得る為にポインターとメモリを頻繁に使用しています。 したがって実行時(実行プロセス中)に*NodeのValue()メソッドを呼び出すと誤った結果になる可能性があります。 もし実行時(例えば学習段階で)にValueに格納されている*Nodeの特定の値にアクセスする必要がある場合はその参照を保持する必要があります。 これがReadメソッドを使用している理由です。 predictedは $X\\cdot\\Theta$ の結果の値を常に格納しています。\n 勾配計算の準備 Gorgoniaの象徴的な微分機能を使います。\nまずコスト関数を作成し solver を使用して勾配降下を実行しコストを下げます。\nコストを保持するノードの作成 コスト($cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$) を追加することにより exprgraphを補完します。\nsquaredError := must(gorgonia.Square(must(gorgonia.Sub(pred, y)))) cost := must(gorgonia.Mean(squaredError)) このコストを下げたいので $\\ Theta$ に関する勾配を評価します:\nif _, err := gorgonia.Grad(cost, theta); err != nil { log.Fatalf(\u0026#34;Failed to backpropagate: %v\u0026#34;, err) } 勾配降下法 勾配降下のメカニズムを使用します。これは勾配を使用してパラメーター $\\ Theta$ を段階的に調節することを意味します。\n基本的な勾配降下はGorgoniaのVanilla Solverによって実装されています。 学習率 $\\ gamma$ を0.001に設定します。\nsolver := gorgonia.NewVanillaSolver(gorgonia.WithLearnRate(0.001)) そして各ステップで勾配に感謝しつつsolverに $ \\ Theta$ パラメーターを更新するように依頼します。 したがってイテレーションごとにsolverに渡す変数 update を設定します。\n勾配降下はこの方程式に従って各ステップで []gorgonia.ValueGrad に渡されるすべての値を更新します。 ${\\displaystyle x^{(k+1)}=x^{(k)}-\\gamma \\nabla f\\left(x^{(k)}\\right)}$ solverはNodesではなくValuesで動作することを理解する事が重要です。 ただし物事を簡単にする為にValueGradは*Node構造によって実現される interface{} になっています。\n この場合 $\\ Theta$ を最適化し次のようにsolverに値を更新する様に依頼します。\n${\\displaystyle \\Theta^{(k+1)}=\\Theta^{(k)}-\\gamma \\nabla f\\left(\\Theta^{(k)}\\right)}$\nそのためには $\\ Theta$ をSolverのStepメソッドに渡す必要があります。\nupdate := []gorgonia.ValueGrad{theta} // ... if err = solver.Step(update); err != nil { log.Fatal(err) } The learning iterations 原理が分かりましたね。幾らかの勾配降下の魔法を起こし得る vm を使用して計算を実行する必要があります。\nvm を作成してグラフを実行します(そして勾配計算を行います):\nmachine := gorgonia.NewTapeMachine(g, gorgonia.BindDualValues(theta)) defer machine.Close() solverにパラメーター $\\ Theta$ についての勾配を更新するように依頼します。 そのためTapeMachineに $\\ Theta$ の値(言わば2次元の値)を保存するよう指示しなければなりません。 これは BindDualValues 関数を使用して行います。\n では各ステップでループを作成してグラフを実行しましょう; さぁ機械が学習します!\niter := 1000000 var err error for i := 0; i \u0026lt; iter; i++ { if err = machine.RunAll(); err != nil { fmt.Printf(\u0026#34;Error during iteration: %v: %v\\n\u0026#34;, i, err) break } if err = solver.Step(model); err != nil { log.Fatal(err) } machine.Reset() // Reset is necessary in a loop like this } 幾らかの情報を取得 この呼び出しを使用して学習プロセスの情報をダンプできます\nfmt.Printf(\u0026#34;theta: %2.2f Iter: %v Cost: %2.3f Accuracy: %2.2f \\r\u0026#34;, theta.Value(), i, cost.Value(), accuracy(predicted.Data().([]float64), y.Value().Data().([]float64))) accuracy は以下の様に定義しました:\nfunc accuracy(prediction, y []float64) float64 { var ok float64 for i := 0; i \u0026lt; len(prediction); i++ { if math.Round(prediction[i]-y[i]) == 0 { ok += 1.0 } } return ok / float64(len(y)) } これにより学習プロセス中には以下の様な行が表示されます:\ntheta: [ 0.26 -0.41 0.44 -0.62 0.83] Iter: 26075 Cost: 0.339 Accuracy: 0.61 weightsの保存 訓練が完了したら予測を行えるように $\\ Theta$ の値を保存します:\nfunc save(value gorgonia.Value) error { f, err := os.Create(\u0026#34;theta.bin\u0026#34;) if err != nil { return err } defer f.Close() enc := gob.NewEncoder(f) err = enc.Encode(value) if err != nil { return err } return nil } 推論を行う簡単なcliを作る まずは訓練フェーズからパラメータを読み込んでみましょう：\nfunc main() { f, err := os.Open(\u0026#34;theta.bin\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() dec := gob.NewDecoder(f) var thetaT *tensor.Dense err = dec.Decode(\u0026amp;thetaT) if err != nil { log.Fatal(err) } では前に行った様にモデル(exprgraph)を作成します:\n実際のアプリケーションはおそらく別のパッケージでモデルを共有する事になるでしょう\n g := gorgonia.NewGraph() theta := gorgonia.NodeFromAny(g, thetaT, gorgonia.WithName(\u0026#34;theta\u0026#34;)) values := make([]float64, 5) xT := tensor.New(tensor.WithBacking(values)) x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y, err := gorgonia.Mul(x, theta) そして標準入力から情報を取得するforループに入り計算を実行して結果を表示します:\nmachine := gorgonia.NewTapeMachine(g) values[4] = 1.0 for { values[0] = getInput(\u0026#34;sepal length\u0026#34;) values[1] = getInput(\u0026#34;sepal widt\u0026#34;) values[2] = getInput(\u0026#34;petal length\u0026#34;) values[3] = getInput(\u0026#34;petal width\u0026#34;) if err = machine.RunAll(); err != nil { log.Fatal(err) } switch math.Round(y.Value().Data().(float64)) { case 1: fmt.Println(\u0026#34;It is probably a setosa\u0026#34;) case 2: fmt.Println(\u0026#34;It is probably a virginica\u0026#34;) case 3: fmt.Println(\u0026#34;It is probably a versicolor\u0026#34;) default: fmt.Println(\u0026#34;unknown iris\u0026#34;) } machine.Reset() } 以下は入力を得る為の便利関数です:\nfunc getInput(s string) float64 { reader := bufio.NewReader(os.Stdin) fmt.Printf(\u0026#34;%v: \u0026#34;, s) text, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) text = strings.Replace(text, \u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;, -1) input, err := strconv.ParseFloat(text, 64) if err != nil { log.Fatal(err) } return input } go build や go run を実行できます。そして そう ! 特徴を考慮して、あやめの種別を予測できる完全に自律的なcliになりました:\n$ go run main.go sepal length: 4.4 sepal widt: 2.9 petal length: 1.4 petal width: 0.2 It is probably a setosa sepal length: 5.9 sepal widt: 3.0 petal length: 5.1 petal width: 1.8 It is probably a virginica Conclusion これは段階的な例です。 thetaの初期値を操作したりGorgoniaの中で物事がどの様に行われるのかを見る為にsolverを変更して試してみましょう。\n全体のコードはGorgoniaプロジェクトのexampleで見つける事ができます。.\nボーナス: 視覚的表現 gonum plotter ライブラリを使えばデータセットを可視化する事ができます。 これを実現する方法の簡単な例を次に示します:\nimport ( \u0026#34;gonum.org/v1/plot\u0026#34; \u0026#34;gonum.org/v1/plot/plotter\u0026#34; \u0026#34;gonum.org/v1/plot/plotutil\u0026#34; \u0026#34;gonum.org/v1/plot/vg\u0026#34; \u0026#34;gonum.org/v1/plot/vg/draw\u0026#34; ) func plotData(x []float64, a []float64) []byte { p, err := plot.New() if err != nil { log.Fatal(err) } p.Title.Text = \u0026#34;sepal length \u0026amp; width\u0026#34; p.X.Label.Text = \u0026#34;length\u0026#34; p.Y.Label.Text = \u0026#34;width\u0026#34; p.Add(plotter.NewGrid()) l := len(x) / len(a) for k := 1; k \u0026lt;= 3; k++ { data0 := make(plotter.XYs, 0) for i := 0; i \u0026lt; len(a); i++ { if k != int(a[i]) { continue } x1 := x[i*l+0] // sepal_length \ty1 := x[i*l+1] // sepal_width \tdata0 = append(data0, plotter.XY{X: x1, Y: y1}) } data, err := plotter.NewScatter(data0) if err != nil { log.Fatal(err) } data.GlyphStyle.Color = plotutil.Color(k - 1) data.Shape = \u0026amp;draw.PyramidGlyph{} p.Add(data) p.Legend.Add(fmt.Sprint(k), data) } w, err := p.WriterTo(4*vg.Inch, 4*vg.Inch, \u0026#34;png\u0026#34;) if err != nil { panic(err) } var b bytes.Buffer writer := bufio.NewWriter(\u0026amp;b) w.WriteTo(writer) ioutil.WriteFile(\u0026#34;out.png\u0026#34;, b.Bytes(), 0644) return b.Bytes() }"},{"uri":"/jp/how-to/dataframe/","title":"データフレームからテンソルを作成 (gota)","tags":[],"description":"","content":" このハウツーでは、gotaを使用してデータフレームからテンソルを作成する方法を説明します。 The goal is to read a csv file and create a *tensor.Dense with shape (2,2). ゴールは、csvファイルを読み取り、(2,2) のシェイプの* tensor.Denseを作成することです。\ncsvファイルからデータフレームを作成する 以下のコンテンツのcsvファイルを考えます:\nsepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... これはIris flower data setからの抜粋です。 データセットのコピーはここから見つける事ができます。\n 種別以外のすべての値を含むテンソルを作成します。\ngotaを使用してデータフレームを作成する gotaのデータフレームパッケージにはio.Readerを引数として取る関数ReadCSVがあります。\nf, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) dfがファイルに存在する全てのデータが含まれるDataFrameです。\ngotaはデータフレームの列を参照する為にCSVの最初の行を使用します。\n 種別(species)カラムを削除しましょう:\nxDF := df.Drop(\u0026#34;species\u0026#34;) データフレームを行列に変換する 物事を簡単にするために、データフレームをgonumで定義されているMatrixに変換します(matrixのgodocを参照)。 matrixはインタフェースです。gotaのデータフレームはMatrixインターフェイスを満たしません。gotaのドキュメントに記載されているように、 Matrixインターフェイスを満たすために、データフレームのラッパーを作成します。\ntype matrix struct { dataframe.DataFrame } func (m matrix) At(i, j int) float64 { return m.Elem(i, j).Float() } func (m matrix) T() mat.Matrix { return mat.Transpose{Matrix: m} } テンソルを作る データフレームをmatrix構造体の中にラッピングすると関数tensor.FromMat64のおかげで*Denseテンソルを作成できるようになります。\nxT := tensor.FromMat64(mat.DenseCopyOf(\u0026amp;matrix{xDF}))"},{"uri":"/jp/","title":"main","tags":[],"description":"","content":" Gorgonia GorgoniaはGoでの機械学習を楽にするためのライブラリです。\n多次元配列を含む数式を簡単に記述して評価します。\nTheanoまたはTensorFlowに似た物の様に感じるかもしれませんが場合、それはアイデアが非常に似ているためです。\n具体的にはライブラリはTheanoのようにかなり低レベルですが、Tensorflowの様なより高い目標を持っています。\nなぜGorgoniaを使うのか? Gorgoniaを使用する主な理由は開発者を楽にする事です。Goスタックを広範囲に使用しているのであれば使い慣れた環境で実稼働対応の機械学習システムを作成する機能にアクセスできます。\n大儀ではML/AIは2つのステージに分類されます。1つはさまざまなモデルを構築しテストと再テストを行う実験のステージ。またテストを実施し実際に試され、デプロイされた後のモデルがあるステージ。これらはデータサイエンティストとデータエンジニアのように異なる役割を必要とします。\n通常、2つのフェーズには異なるツールが存在します。Python/Lua（Theano、Torchなどを使用)が一般的に使用されます 実験の段階では、C++(dlib、mlpack等より高性能な言語でモデルが書き換えられます)。もちろん今日では格差は縮まりつつあり、人々は頻繁にツールを共有しています。 Tensorflowはこのギャップを埋めるツールの1つです。\nGorgoniaは同じ場所を目指していますがGo環境を提供します。Gorgoniaは現在とても良い性能を発揮します - その速度はTheanoとTensorflowのCPU実装に匹敵します。 GPUの実装はcgoの負担が重いため比較するには多少手間がかかりますが、これらは現在、積極的に改善を行っている領域ですのでご安心ください。\nこのウェブサイトの構成は? このウェブサイトはさまざまなゴールを持つ4つのセクションで構成されています:\n はじめに Gorgoniaの仕組みに関する全ての情報が含まれます リファレンス ハウツー チュートリアル  "},{"uri":"/jp/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"/jp/tags/","title":"Tags","tags":[],"description":"","content":""}]
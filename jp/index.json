[{"uri":"/jp/tutorials/hello-world/","title":"こんにちわ世界","tags":[],"description":"","content":" これはGorgoniaでとても簡単な計算を行うための段階的なチュートリアルです。\n私たちのゴールはGorgoniaのすべての配管を使用して簡単な操作を行うことです:\n$ f(x,y) = x + y $\nwith x = 2 and y = 5\nどの様に動作するか x + y = z の評価はグラフで表す事ができます:\ngraph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y  結果を計算する為に4つのステップを使います:\n Make a similar graph with Gorgonia sets some values on the nodes x and y then instanciate a graph on a gorgonia vm extract the value from node z *  Create a graph Create an empty expression graph with this method:\ng := gorgonia.NewGraph() Create the nodes We will create some nodes and associate them to the ExprGraph.\nvar x, y, z *gorgonia.Node Create the placeholder x and y are scalar variables, we can create the corresponding node with:\nx = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) the functions take the exprgraph as argument; the resulting node is automatically associated to the graph.\n Now create the addition operator; this operator takes two nodes and returns a new node z:\nif z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) }  the returning node z is added to the graph even if g is not passed to z or to the Add function.\n Set the values We have a ExprGraph that represents the equation z = x + y. Now it\u0026rsquo;s time to assign some values to x and y.\nWe use the Let function:\ngorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) Run the graph To run the graph and compute the result, we need to instanciate a VM. Let\u0026rsquo;s use the TapeMachine:\nmachine := gorgonia.NewTapeMachine(g) defer machine.Close() and run the graph:\nif err = machine.RunAll(); err != nil { log.Fatal(err) } 2回目の実行が必要な場合vmオブジェクトのReset()メソッドを呼び出すことが必須です: machine.Reset()\n 値の取得 これでノードzが結果を保持します。 Valueを抽出するにはValue()メソッドを呼び出します:\nfmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) この場合float64を保持するinterface{}を返すz.Value().Data()を呼び出して、基になる\u0026rdquo;Go\u0026rdquo;値にアクセスすることもできます。\n 最終結果 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) }$ go run main.go 4.5"},{"uri":"/jp/about/","title":"Gorgoniaの仕組み","tags":[],"description":"","content":"このセクションにはGorgoniaの仕組みを説明することを目的とした記事が含まれています。\nこのセクションの記事は次のとおり:\n 理解志向である 背景とコンテキストを提供  類似品: 料理の社会史に関する記事\n"},{"uri":"/jp/tutorials/","title":"チュートリアル","tags":[],"description":"","content":"Gorgoniaのさまざまな使われ方を試し始める為のさまざまなチュートリアル。\nこのチュートリアルは:\n 学習指向 新たな人でも始められる 1つずつのレッスン  類似品: 子供に料理の仕方を教える方法\n"},{"uri":"/jp/how-to/","title":"ハウツー","tags":[],"description":"","content":"Gorgoniaでさまざまな機械学習を行う方法。\nこのセクションではGorgoniaを使用してさまざまな問題を解決する方法を説明します。\n以下の様なハウツーガイドです:\n 目標指向 特定の問題を解決する方法を示します 理解可能な手順で構成します  類似品：料理本のレシピ\n"},{"uri":"/jp/how-to/dataframe/","title":"データフレームからテンソルを作成 (gota)","tags":[],"description":"","content":" このハウツーでは、gotaを使用してデータフレームからテンソルを作成する方法を説明します。 The goal is to read a csv file and create a *tensor.Dense with shape (2,2). ゴールは、csvファイルを読み取り、(2,2) のシェイプの* tensor.Denseを作成することです。\ncsvファイルからデータフレームを作成する 以下のコンテンツのcsvファイルを考えます:\nsepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... これはIris flower data setからの抜粋です。 データセットのコピーはここから見つける事ができます。\n 種別以外のすべての値を含むテンソルを作成します。\ngotaを使用してデータフレームを作成する gotaのデータフレームパッケージにはio.Readerを引数として取る関数ReadCSVがあります。\nf, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) dfがファイルに存在する全てのデータが含まれるDataFrameです。\ngotaはデータフレームの列を参照する為にCSVの最初の行を使用します。\n 種別(species)カラムを削除しましょう:\nxDF := df.Drop(\u0026#34;species\u0026#34;) データフレームを行列に変換する To make things easier, we will convert our dataframe into a Matrix as defined by gonum (see the matrix godoc). 物事を簡単にするために、データフレームをgonumで定義されているMatrixに変換します(matrixのgodocを参照)。 matrixはインタフェースです。gotaのデータフレームはMatrixインターフェイスを満たしません。gotaのドキュメントに記載されているように、 Matrixインターフェイスを満たすために、データフレームのラッパーを作成します。\ntype matrix struct { dataframe.DataFrame } func (m matrix) At(i, j int) float64 { return m.Elem(i, j).Float() } func (m matrix) T() mat.Matrix { return mat.Transpose{Matrix: m} } テンソルを作る データフレームをmatrix構造体の中にラッピングすると関数tensor.FromMat64のおかげで*Denseテンソルを作成できるようになります。\nxT := tensor.FromMat64(mat.DenseCopyOf(\u0026amp;matrix{xDF}))"},{"uri":"/jp/","title":"main","tags":[],"description":"","content":" Gorgonia GorgoniaはGoでの機械学習を楽にするためのライブラリです。\n多次元配列を含む数式を簡単に記述して評価します。\nTheanoまたはTensorFlowに似た物の様に感じるかもしれませんが場合、それはアイデアが非常に似ているためです。\n具体的にはライブラリはTheanoのようにかなり低レベルですが、Tensorflowの様なより高い目標を持っています。\nなぜGorgoniaを使うのか? Gorgoniaを使用する主な理由は開発者を楽にする事です。Goスタックを広範囲に使用しているのであれば使い慣れた環境で実稼働対応の機械学習システムを作成する機能にアクセスできます。\n大儀ではML/AIは2つのステージに分類されます。1つはさまざまなモデルを構築しテストと再テストを行う実験のステージ。またテストを実施し実際に試され、デプロイされた後のモデルがあるステージ。これらはデータサイエンティストとデータエンジニアのように異なる役割を必要とします。\n通常、2つのフェーズには異なるツールが存在します。Python/Lua（Theano、Torchなどを使用)が一般的に使用されます 実験の段階では、C++(dlib、mlpack等より高性能な言語でモデルが書き換えられます)。もちろん今日では格差は縮まりつつあり、人々は頻繁にツールを共有しています。 Tensorflowはこのギャップを埋めるツールの1つです。\nGorgoniaは同じ場所を目指していますがGo環境を提供します。Gorgoniaは現在とても良い性能を発揮します - その速度はTheanoとTensorflowのCPU実装に匹敵します。 GPUの実装はcgoの負担が重いため比較するには多少手間がかかりますが、これらは現在、積極的に改善を行っている領域ですのでご安心ください。\nこのウェブサイトの構成は? このウェブサイトはさまざまなゴールを持つ4つのセクションで構成されています:\n はじめに Gorgoniaの仕組みに関する全ての情報が含まれます リファレンス ハウツー チュートリアル  "},{"uri":"/jp/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"/jp/tags/","title":"Tags","tags":[],"description":"","content":""}]